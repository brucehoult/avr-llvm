Index: include/clang/Basic/DiagnosticSemaKinds.td
===================================================================
--- include/clang/Basic/DiagnosticSemaKinds.td	(revisión: 153046)
+++ include/clang/Basic/DiagnosticSemaKinds.td	(copia de trabajo)
@@ -4457,6 +4457,12 @@
   "'%0' attribute only applies to functions with no arguments">;
 def err_isr_not_void_return : Error<
   "'%0' attribute only applies to functions with a void return type">;
+def err_flash_variable_not_assignable : Error<
+  "flash variable is not assignable">;
+def err_flash_variable_requires_const : Error<
+  "flash variable requires const qualifier">;
+def err_flash_pointer_requires_const : Error<
+  "flash pointer datum requires a const qualifier">;
 
 def err_cannot_pass_objc_interface_to_vararg : Error<
   "cannot pass object with interface type %0 by-value through variadic "

Index: lib/Sema/SemaDecl.cpp
===================================================================
--- lib/Sema/SemaDecl.cpp	(revisión: 153046)
+++ lib/Sema/SemaDecl.cpp	(copia de trabajo)
@@ -4297,6 +4297,23 @@
     return false;
   }
 
+  // Emit an error when the variable being declared is stored in flash memory
+  // and it is not const qualified.
+  if (T.getAddressSpace() == 1 && !T.isConstQualified()) {
+    Diag(NewVD->getLocation(), diag::err_flash_variable_requires_const);
+    NewVD->setInvalidDecl();
+    return false;
+  }
+
+  // Emit an error when the pointee type of a pointer is not const qualified
+  // and points to flash memory.
+  if (T->isPointerType() && !T->getPointeeType().isConstQualified()
+      && T->getPointeeType().getAddressSpace() == 1) {
+    Diag(NewVD->getLocation(), diag::err_flash_pointer_requires_const);
+    NewVD->setInvalidDecl();
+    return false;
+  }
+
   if (NewVD->hasLocalStorage() && T.isObjCGCWeak()
       && !NewVD->hasAttr<BlocksAttr>()) {
     if (getLangOpts().getGC() != LangOptions::NonGC)
@@ -7100,8 +7117,16 @@
   if (T.getAddressSpace() != 0) {
     Diag(NameLoc, diag::err_arg_with_address_space);
     New->setInvalidDecl();
-  }   
+  }
 
+  // Emit an error when the pointee type of a pointer is not const qualified
+  // and points to flash memory.
+  if (T->isPointerType() && !T->getPointeeType().isConstQualified()
+      && T->getPointeeType().getAddressSpace() == 1) {
+    Diag(NameLoc, diag::err_flash_pointer_requires_const);
+    New->setInvalidDecl();
+  }
+
   return New;
 }
 
===================================================================
--- lib/Sema/SemaExpr.cpp	(revisión: 153046)
+++ lib/Sema/SemaExpr.cpp	(copia de trabajo)
@@ -7165,8 +7165,17 @@
     IsLV = Expr::MLV_Valid;
   else if (IsLV == Expr::MLV_ClassTemporary && IsReadonlyMessage(E, S))
     IsLV = Expr::MLV_InvalidMessageExpression;
-  if (IsLV == Expr::MLV_Valid)
+  if (IsLV == Expr::MLV_Valid) {
+    // If everything is valid then check if the variable being assigned is
+    // stored in flash memory and emit an error if that is the case.
+    if (E->getType().getAddressSpace() == 1) {
+      SourceRange Assign;
+      S.Diag(Loc, diag::err_flash_variable_not_assignable)
+        << E->getSourceRange() << Assign;
+      return true;
+    }
     return false;
+  }
 
   unsigned Diag = 0;
   bool NeedType = false;
