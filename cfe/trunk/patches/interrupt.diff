Index: include/clang/Basic/Attr.td
===================================================================
--- include/clang/Basic/Attr.td	(revision 152010)
+++ include/clang/Basic/Attr.td	(working copy)
@@ -336,6 +336,14 @@
   let Spellings = [];
 }
 
+def AVRInterruptHandler : InheritableAttr {
+  let Spellings = [];
+}
+
+def AVRInterrupt : InheritableAttr {
+  let Spellings = ["interrupt"];
+}
+
 def Naked : InheritableAttr {
   let Spellings = ["naked"];
 }
Index: lib/Sema/TargetAttributesSema.cpp
===================================================================
--- lib/Sema/TargetAttributesSema.cpp	(revision 152010)
+++ lib/Sema/TargetAttributesSema.cpp	(working copy)
@@ -120,6 +120,39 @@
   };
 }
 
+static void HandleAVRInterruptHandlerAttr(Decl *d, const AttributeList &Attr,
+                                          Sema &S) {
+  // Check the attribute arguments.
+  if (Attr.getNumArgs() != 0) {
+    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments) << 0;
+    return;
+  }
+
+  // FIXME: Check for decl - it should be void ()(void).
+
+  d->addAttr(::new (S.Context) AVRInterruptHandlerAttr(Attr.getLoc(),
+                                                       S.Context));
+  d->addAttr(::new (S.Context) UsedAttr(Attr.getLoc(), S.Context));
+}
+
+namespace {
+  class AVRAttributesSema : public TargetAttributesSema {
+  public:
+    AVRAttributesSema() { }
+    bool ProcessDeclAttribute(Scope *scope, Decl *D, const AttributeList &Attr,
+                              Sema &S) const {
+      if (Attr.getName()->getName() == "signal") {
+        HandleAVRInterruptHandlerAttr(D, Attr, S);
+        return true;
+      } /*else if (Attr.getName()->getName() == "interrupt") {
+        //:TODO:
+        return true;
+      }*/
+      return false;
+    }
+  };
+}
+
 static void HandleX86ForceAlignArgPointerAttr(Decl *D,
                                               const AttributeList& Attr,
                                               Sema &S) {
@@ -272,6 +305,8 @@
   case llvm::Triple::x86:
   case llvm::Triple::x86_64:
     return *(TheTargetAttributesSema = new X86AttributesSema);
+  case llvm::Triple::avr:
+    return *(TheTargetAttributesSema = new AVRAttributesSema);
   default:
     return *(TheTargetAttributesSema = new TargetAttributesSema);
   }
Index: lib/CodeGen/TargetInfo.cpp
===================================================================
--- lib/CodeGen/TargetInfo.cpp	(revision 152010)
+++ lib/CodeGen/TargetInfo.cpp	(working copy)
@@ -3000,6 +3000,82 @@
 
 
 //===----------------------------------------------------------------------===//
+// AVR ABI Implementation
+//===----------------------------------------------------------------------===//
+namespace {
+
+class AVRABIInfo : public ABIInfo
+{
+public:
+  AVRABIInfo(CodeGenTypes &CGT) : ABIInfo(CGT) {}
+
+  ABIArgInfo classifyReturnType(QualType RetTy) const;
+  ABIArgInfo classifyArgumentType(QualType RetTy) const;
+
+  virtual void computeInfo(CGFunctionInfo &FI) const {
+    FI.getReturnInfo() = classifyReturnType(FI.getReturnType());
+    for (CGFunctionInfo::arg_iterator it = FI.arg_begin(), ie = FI.arg_end();
+         it != ie; ++it)
+      it->info = classifyArgumentType(it->type);
+  }
+
+  virtual llvm::Value *EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
+                                 CodeGenFunction &CGF) const;
+};
+
+class AVRTargetCodeGenInfo : public TargetCodeGenInfo
+{
+public:
+  AVRTargetCodeGenInfo(CodeGenTypes &CGT)
+    : TargetCodeGenInfo(new AVRABIInfo(CGT)) {}
+  void SetTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
+                           CodeGen::CodeGenModule &M) const;
+};
+
+}
+
+llvm::Value *AVRABIInfo::EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
+                                   CodeGenFunction &CGF) const {
+  // FIXME: Implement
+  return 0;
+}
+
+
+ABIArgInfo AVRABIInfo::classifyReturnType(QualType RetTy) const {
+  if (RetTy->isVoidType())
+    return ABIArgInfo::getIgnore();
+  if (isAggregateTypeForABI(RetTy))
+    return ABIArgInfo::getIndirect(0);
+
+  return ABIArgInfo::getDirect();
+}
+
+ABIArgInfo AVRABIInfo::classifyArgumentType(QualType Ty) const {
+  if (isAggregateTypeForABI(Ty))
+    return ABIArgInfo::getIndirect(0);
+
+  return ABIArgInfo::getDirect();
+}
+
+void AVRTargetCodeGenInfo::SetTargetAttributes(const Decl *D,
+                                               llvm::GlobalValue *GV,
+                                               CodeGen::CodeGenModule &M) const{
+  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
+    if (FD->hasAttr<AVRInterruptHandlerAttr>()) {
+      // Handle 'signal' attribute:
+      llvm::Function *F = dyn_cast<llvm::Function>(GV);
+      if (!F) return;
+
+      // Step 1: Set ISR calling convention.
+      F->setCallingConv(llvm::CallingConv::AVR_INTR);
+
+      // Step 2: Add attributes goodness.
+      F->addFnAttr(llvm::Attribute::NoInline);
+    }
+  }
+}
+
+//===----------------------------------------------------------------------===//
 // MSP430 ABI Implementation
 //===----------------------------------------------------------------------===//
 
@@ -3591,6 +3667,9 @@
   case llvm::Triple::mblaze:
     return *(TheTargetCodeGenInfo = new MBlazeTargetCodeGenInfo(Types));
 
+  case llvm::Triple::avr:
+    return *(TheTargetCodeGenInfo = new AVRTargetCodeGenInfo(Types));
+
   case llvm::Triple::msp430:
     return *(TheTargetCodeGenInfo = new MSP430TargetCodeGenInfo(Types));
 
