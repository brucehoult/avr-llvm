Index: include/clang/Basic/Attr.td
===================================================================
--- include/clang/Basic/Attr.td (revisión: 156172)
+++ include/clang/Basic/Attr.td (copia de trabajo)
@@ -379,6 +379,16 @@
   let SemaHandler = 0;
 }

+def AVRSignalHandler : InheritableAttr {
+  let Spellings = [];
+  let SemaHandler = 0;
+}
+
+def AVRInterruptHandler : InheritableAttr {
+  let Spellings = [];
+  let SemaHandler = 0;
+}
+
 def MBlazeInterruptHandler : InheritableAttr {
   let Spellings = [];
   let SemaHandler = 0;
Index: include/clang/Basic/DiagnosticSemaKinds.td
===================================================================
--- include/clang/Basic/DiagnosticSemaKinds.td	(revision 156247)
+++ include/clang/Basic/DiagnosticSemaKinds.td	(working copy)
@@ -4604,6 +4604,10 @@
   "reference to %select{__device__|__global__|__host__|__host__ __device__}0 "
   "function %1 in %select{__device__|__global__|__host__|__host__ __device__}2 function">;
 
+def err_isr_has_arguments : Error<
+  "'%0' attribute only applies to functions with no arguments">;
+def err_isr_not_void_return : Error<
+  "'%0' attribute only applies to functions with a void return type">;
 
 def err_cannot_pass_objc_interface_to_vararg : Error<
   "cannot pass object with interface type %0 by-value through variadic "
Index: lib/Sema/TargetAttributesSema.cpp
===================================================================
--- lib/Sema/TargetAttributesSema.cpp	(revisión: 152164)
+++ lib/Sema/TargetAttributesSema.cpp	(copia de trabajo)
@@ -120,6 +120,64 @@
   };
 }
 
+static void HandleAVRIsrAttr(Decl *d, const AttributeList &Attr, Sema &S,
+                             bool isSignal) {
+  // Check the attribute arguments.
+  if (Attr.getNumArgs() != 0) {
+    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_number_arguments) << 0;
+    return;
+  }
+
+  // Attribute can only be applied to function types.
+  if (!isa<FunctionDecl>(d)) {
+    S.Diag(Attr.getLoc(), diag::err_attribute_wrong_decl_type)
+      << Attr.getName() << 0;
+    return;
+  }
+
+  FunctionDecl *FD = dyn_cast<FunctionDecl>(d);
+  // Attribute not allowed when the function declaration has arguments
+  if (FD->getNumParams() != 0) {
+    S.Diag(Attr.getLoc(), diag::err_isr_has_arguments)
+      << Attr.getName()->getName();
+    return;
+  }
+
+  // Attribute not allowed when the function declaration has a return type
+  if (!FD->getResultType()->isVoidType()) {
+    S.Diag(Attr.getLoc(), diag::err_isr_not_void_return)
+      << Attr.getName()->getName();
+    return;
+  }
+
+  if (isSignal)
+    d->addAttr(::new (S.Context) AVRSignalHandlerAttr(Attr.getLoc(),
+                                                      S.Context));
+  else
+    d->addAttr(::new (S.Context) AVRInterruptHandlerAttr(Attr.getLoc(),
+                                                         S.Context));
+
+  d->addAttr(::new (S.Context) UsedAttr(Attr.getLoc(), S.Context));
+}
+
+namespace {
+  class AVRAttributesSema : public TargetAttributesSema {
+  public:
+    AVRAttributesSema() { }
+    bool ProcessDeclAttribute(Scope *scope, Decl *D, const AttributeList &Attr,
+                              Sema &S) const {
+      if (Attr.getName()->getName() == "signal") {
+        HandleAVRIsrAttr(D, Attr, S, true);
+        return true;
+      } else if (Attr.getName()->getName() == "interrupt") {
+        HandleAVRIsrAttr(D, Attr, S, false);
+        return true;
+      }
+      return false;
+    }
+  };
+}
+
 static void HandleX86ForceAlignArgPointerAttr(Decl *D,
                                               const AttributeList& Attr,
                                               Sema &S) {
@@ -272,6 +330,8 @@
   case llvm::Triple::x86:
   case llvm::Triple::x86_64:
     return *(TheTargetAttributesSema = new X86AttributesSema);
+  case llvm::Triple::avr:
+    return *(TheTargetAttributesSema = new AVRAttributesSema);
   default:
     return *(TheTargetAttributesSema = new TargetAttributesSema);
   }
Index: lib/CodeGen/TargetInfo.cpp
===================================================================
--- lib/CodeGen/TargetInfo.cpp	(revision 156247)
+++ lib/CodeGen/TargetInfo.cpp	(working copy)
@@ -3049,7 +3049,97 @@
                           "_interrupt_handler", GV, &M.getModule());
 }
 
+//===----------------------------------------------------------------------===//
+// AVR ABI Implementation
+//===----------------------------------------------------------------------===//
 
+namespace {
+
+class AVRABIInfo : public ABIInfo
+{
+public:
+  AVRABIInfo(CodeGenTypes &CGT) : ABIInfo(CGT) {}
+
+  ABIArgInfo classifyReturnType(QualType RetTy) const;
+  ABIArgInfo classifyArgumentType(QualType RetTy) const;
+
+  virtual void computeInfo(CGFunctionInfo &FI) const {
+    FI.getReturnInfo() = classifyReturnType(FI.getReturnType());
+    for (CGFunctionInfo::arg_iterator it = FI.arg_begin(), ie = FI.arg_end();
+         it != ie; ++it)
+      it->info = classifyArgumentType(it->type);
+  }
+
+  virtual llvm::Value *EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
+                                 CodeGenFunction &CGF) const;
+};
+
+class AVRTargetCodeGenInfo : public TargetCodeGenInfo
+{
+public:
+  AVRTargetCodeGenInfo(CodeGenTypes &CGT)
+    : TargetCodeGenInfo(new AVRABIInfo(CGT)) {}
+  void SetTargetAttributes(const Decl *D, llvm::GlobalValue *GV,
+                           CodeGen::CodeGenModule &M) const;
+};
+
+}
+
+llvm::Value *AVRABIInfo::EmitVAArg(llvm::Value *VAListAddr, QualType Ty,
+                                   CodeGenFunction &CGF) const {
+  // FIXME: Implement
+  return 0;
+}
+
+
+ABIArgInfo AVRABIInfo::classifyReturnType(QualType RetTy) const {
+  if (RetTy->isVoidType())
+    return ABIArgInfo::getIgnore();
+  if (isAggregateTypeForABI(RetTy))
+    return ABIArgInfo::getIndirect(0);
+
+  return ABIArgInfo::getDirect();
+}
+
+ABIArgInfo AVRABIInfo::classifyArgumentType(QualType Ty) const {
+  if (isAggregateTypeForABI(Ty))
+    return ABIArgInfo::getIndirect(0);
+
+  return ABIArgInfo::getDirect();
+}
+
+void AVRTargetCodeGenInfo::SetTargetAttributes(const Decl *D,
+                                               llvm::GlobalValue *GV,
+                                               CodeGen::CodeGenModule &M) const{
+  if (const FunctionDecl *FD = dyn_cast<FunctionDecl>(D)) {
+    if (llvm::Function *F = dyn_cast<llvm::Function>(GV)) {
+      if (FD->hasAttr<AVRSignalHandlerAttr>()) {
+        // Handle 'signal' attribute:
+
+        // Step 1: Set ISR calling convention.
+        // The 'interrupt' attribute overrides the 'signal' attribute
+        if (FD->hasAttr<AVRInterruptHandlerAttr>())
+          F->setCallingConv(llvm::CallingConv::AVR_INTR);
+        else
+          F->setCallingConv(llvm::CallingConv::AVR_SIGNAL);
+      } else if (FD->hasAttr<AVRInterruptHandlerAttr>()) {
+        // Handle 'interrupt' attribute:
+
+        // Step 1: Set ISR calling convention.
+        F->setCallingConv(llvm::CallingConv::AVR_INTR);
+      }
+
+      // Step 2: Add attributes goodness.
+      F->addFnAttr(llvm::Attribute::NoInline);
+    }
+  } else
+    // Global variables that do not belong to the generic address space and
+    // have common linkage are set to have external linkage.
+    if ((GV->getType()->getAddressSpace() != 0)
+        && (GV->getLinkage() == llvm::GlobalValue::CommonLinkage))
+      GV->setLinkage(llvm::GlobalValue::ExternalLinkage);
+}
+
 //===----------------------------------------------------------------------===//
 // MSP430 ABI Implementation
 //===----------------------------------------------------------------------===//
@@ -3642,6 +3732,9 @@
   case llvm::Triple::mblaze:
     return *(TheTargetCodeGenInfo = new MBlazeTargetCodeGenInfo(Types));
 
+  case llvm::Triple::avr:
+    return *(TheTargetCodeGenInfo = new AVRTargetCodeGenInfo(Types));
+
   case llvm::Triple::msp430:
     return *(TheTargetCodeGenInfo = new MSP430TargetCodeGenInfo(Types));

