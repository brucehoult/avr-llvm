Index: lib/Basic/Targets.cpp
===================================================================
--- clang/lib/Basic/Targets.cpp	(revision 94389)
+++ clang/lib/Basic/Targets.cpp	(working copy)
@@ -1472,6 +1472,88 @@
 } // end anonymous namespace.
 
 namespace {
+  class AVRTargetInfo : public TargetInfo{
+  public:
+  	AVRTargetInfo(const std::string& triple) : TargetInfo(triple) {
+      TLSSupported = false;
+      IntWidth = 16;
+      LongWidth = LongLongWidth = 32;
+      PointerWidth = 16;
+      IntAlign = 8;
+      LongAlign = LongLongAlign = 8;
+      PointerAlign = 8;
+      SizeType = UnsignedInt;
+      IntMaxType = SignedLong;
+      UIntMaxType = UnsignedLong;
+      IntPtrType = SignedShort;
+      PtrDiffType = SignedInt;
+      FloatWidth = 32;
+      FloatAlign = 32;
+      DoubleWidth = 32;
+      DoubleAlign = 32;
+      LongDoubleWidth = 32;
+      LongDoubleAlign = 32;
+      FloatFormat = &llvm::APFloat::IEEEsingle;
+      DoubleFormat = &llvm::APFloat::IEEEsingle;
+      LongDoubleFormat = &llvm::APFloat::IEEEsingle;
+      DescriptionString = "e-p:16:8:8-i8:8:8-i16:8:8-i32:8:8-f32:32:32";
+    }
+    virtual uint64_t getPointerWidthV(unsigned AddrSpace) const {
+      if (AddrSpace == 1)
+        return 24;
+      else
+        return 16;
+    }
+    
+    virtual uint64_t getPointerAlignV(unsigned AddrSpace) const { return 8; }
+    
+    virtual void getTargetDefines(const LangOptions &Opts,
+                                  MacroBuilder &Builder) const {
+      DefineStd(Builder, "AVR", Opts);
+      //Builder.defineMacro("__AVR_ARCH__", ###);
+      Builder.defineMacro("FUSEMEM", "__attribute__((section(\".fuse\")))");
+      
+      Builder.defineMacro("PROGMEM", "__attribute__((section(\".progmem\")))");
+      Builder.defineMacro("__flash__", "__attribute__((address_space(1)))");
+      
+      Builder.defineMacro("EEMEM", "__attribute__((section(\".eeprom\")))");
+      Builder.defineMacro("__eeprom__", "__attribute__((address_space(2)))");
+    }
+    
+    virtual void getTargetBuiltins(const Builtin::Info *&Records,
+                                   unsigned &NumRecords) const {}
+    virtual const char *getVAListDeclaration() const {
+      return "";
+    }
+    virtual const char *getClobbers() const {
+      return "";
+    }
+    virtual void getGCCRegNames(const char * const *&Names,
+                                unsigned &NumNames) const {}
+    virtual bool validateAsmConstraint(const char *&Name,
+                                       TargetInfo::ConstraintInfo &info) const {
+      return true;
+    }
+    virtual void getGCCRegAliases(const GCCRegAlias *&Aliases,
+                                  unsigned &NumAliases) const {}
+#if 0                                  
+  const char * const MSP430TargetInfo::GCCRegNames[] = {
+    "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+    "r8", "r9", "r10", "r11", "r12", "r13", "r14", "r15"
+  };
+
+  void MSP430TargetInfo::getGCCRegNames(const char * const *&Names,
+                                        unsigned &NumNames) const {
+    Names = GCCRegNames;
+    NumNames = llvm::array_lengthof(GCCRegNames);
+  }                                  
+                                
+  virtual bool useGlobalsForAutomaticVariables() const {return true;}
+#endif  
+  };
+} // end anonymous namespace.
+
+namespace {
 class SparcV8TargetInfo : public TargetInfo {
   static const TargetInfo::GCCRegAlias GCCRegAliases[];
   static const char * const GCCRegNames[];
@@ -2068,7 +2150,10 @@
     default:
       return new ARMTargetInfo(T);
     }
-
+    
+  case llvm::Triple::avr:
+    return new AVRTargetInfo(T);
+    
   case llvm::Triple::bfin:
     return new BlackfinTargetInfo(T);
 
